<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Database Transactions and Concurrency - Study Notes</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px 20px;
            border-radius: 15px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .section {
            background: white;
            margin-bottom: 30px;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
            border-left: 5px solid #667eea;
        }

        .section h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.8em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section h3 {
            color: #444;
            margin: 20px 0 15px 0;
            font-size: 1.3em;
            border-bottom: 2px solid #eee;
            padding-bottom: 5px;
        }

        .highlight {
            background: linear-gradient(120deg, #a8edea 0%, #fed6e3 100%);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 4px solid #667eea;
        }

        .example {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin: 15px 0;
            border: 1px solid #e9ecef;
        }

        .example h4 {
            color: #28a745;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        pre {
            background: #2d3748;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            margin: 15px 0;
        }

        .code-inline {
            background: #f1f3f4;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            color: #d73a49;
            font-size: 0.9em;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        th,
        td {
            padding: 15px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }

        th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: bold;
        }

        tr:hover {
            background: #f8f9fa;
        }

        .acid-cards {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .acid-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            transform: translateY(0);
            transition: transform 0.3s ease;
        }

        .acid-card:hover {
            transform: translateY(-5px);
        }

        .acid-card h3 {
            color: white;
            margin-bottom: 15px;
            font-size: 1.5em;
            border: none;
            padding: 0;
        }

        .problem-grid {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin: 20px 0;
        }

        .problem-card {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 10px;
            padding: 20px;
            border-left: 4px solid #f39c12;
            width: 100%;
        }

        .problem-card h4 {
            color: #f39c12;
            margin-bottom: 10px;
        }

        .success-card {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            border-radius: 10px;
            padding: 20px;
            border-left: 4px solid #28a745;
            width: 100%;
        }

        .success-card h4 {
            color: #28a745;
            margin-bottom: 10px;
        }

        .danger-card {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            border-radius: 10px;
            padding: 20px;
            border-left: 4px solid #dc3545;
            width: 100%;
        }

        .danger-card h4 {
            color: #dc3545;
            margin-bottom: 10px;
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .summary-card {
            background: linear-gradient(135deg, #84fab0 0%, #8fd3f4 100%);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
        }

        .summary-card h4 {
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .image-container {
            text-align: center;
            margin: 20px 0;
        }

        .image-container img {
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .note-tip {
            background: #e8f5e8;
            border: 1px solid #4caf50;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            border-left: 4px solid #4caf50;
        }

        .note-tip::before {
            content: "üí° ";
            font-size: 1.2em;
        }

        .warning {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            border-left: 4px solid #ffc107;
        }

        .warning::before {
            content: "‚ö†Ô∏è ";
            font-size: 1.2em;
        }

        .key-point {
            background: #e3f2fd;
            border: 1px solid #2196f3;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            border-left: 4px solid #2196f3;
        }

        .key-point::before {
            content: "üîë ";
            font-size: 1.2em;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2em;
            }

            .section {
                padding: 20px;
            }

            .acid-cards {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>üíæ Database Transactions and Concurrency</h1>
            <p>Complete Guide for Database Management Systems</p>
        </div>

        <div class="section">
            <h2>üí° What is a Transaction?</h2>
            <div class="highlight">
                <p>A <strong>transaction</strong> is a collection of operations that performs a <strong>single logical unit of work</strong> in a database application.</p>
            </div>

            <div class="example">
                <h4>üîç Real-World Example: Banking Transfer</h4>
                <p>Imagine you're using a banking app to <strong>transfer ‚Çπ1000</strong> from <strong>Account A to Account B</strong>.</p>
                <p>This task involves multiple operations:</p>
                <pre>
1. BEGIN TRANSACTION
2. Deduct ‚Çπ1000 from Account A
3. Add ‚Çπ1000 to Account B
4. COMMIT TRANSACTION
        </pre>
                <p>This entire process is <strong>one transaction</strong>. If any step fails, the whole operation must be rolled back.</p>
            </div>

            <h3>üß± Operations in a Transaction</h3>
            <div class="highlight">
                <p>In a transaction, an <strong>operation</strong> is a single database action like reading, writing, updating, or committing data.</p>
                <p>Multiple operations together complete the logical task of the transaction.</p>
            </div>

            <div class="example">
                <h4>‚úÖ Common Database Operations</h4>
                <ul>
                    <li><strong>BEGIN TRANSACTION</strong> ‚Äì Initialize the transaction</li>
                    <li><strong>READ(X)</strong> ‚Äì Read the value of variable X</li>
                    <li><strong>WRITE(X)</strong> ‚Äì Update the value of variable X</li>
                    <li><strong>COMMIT</strong> ‚Äì Make changes permanent</li>
                    <li><strong>ROLLBACK/ABORT</strong> ‚Äì Cancel transaction and undo changes</li>
                </ul>
            </div>

            <div class="example">
                <h4>üìò Detailed Example: Transfer ‚Çπ1000 from A to B</h4>
                <pre>
Transaction T1:

1. BEGIN TRANSACTION
2. READ(A)           -- Get current balance of Account A
3. A = A - 1000      -- Calculate new balance (deduct ‚Çπ1000)
4. WRITE(A)          -- Update Account A with new balance
5. READ(B)           -- Get current balance of Account B
6. B = B + 1000      -- Calculate new balance (add ‚Çπ1000)
7. WRITE(B)          -- Update Account B with new balance
8. COMMIT            -- Make all changes permanent
        </pre>
            </div>

            <div class="key-point">
                <strong>Key Point:</strong> Each READ and WRITE is an individual operation. Together, all operations form one complete transaction that maintains data integrity.
            </div>
        </div>

        <div class="section">
            <h2>‚úÖ ACID Properties (Critical for Interviews)</h2>
            <p>ACID properties are fundamental principles that ensure database transactions are processed reliably and maintain data integrity, even during system failures or concurrent access.</p>

            <div class="acid-cards">
                <!-- Atomicity -->
                <div class="acid-card">
                    <h3>üîÑ Atomicity</h3>
                    <p>All operations in a transaction are treated as a single, indivisible unit ‚Äì either all operations succeed completely or none are applied at all.</p>
                    <div class="example">
                        <h4>üí° Real-World Example:</h4>
                        <p style="color:black; font-style: italic;">During a ‚Çπ1000 transfer from Account A to B, if the deduction from Account A succeeds but adding to Account B fails, the system must automatically rollback the deduction to maintain consistency.</p>
                        <pre>
BEGIN TRANSACTION
   Deduct ‚Çπ1000 from A ‚Üí SUCCESS
   Add ‚Çπ1000 to B ‚Üí FAILURE
ROLLBACK -- Automatically undo deduction from A
                </pre>
                    </div>
                </div>

                <!-- Consistency -->
                <div class="acid-card">
                    <h3>‚öñÔ∏è Consistency</h3>
                    <p>The database must remain in a valid state before and after the transaction, maintaining all defined rules, constraints, and relationships.</p>
                    <div class="example">
                        <h4>üí° Real-World Example:</h4>
                        <p style="color: black; font-style: italic;">The total money in the banking system must remain constant during transfers. Also, business rules like "account balance cannot be negative" must be enforced.</p>
                        <pre>
Before Transaction:
   A = ‚Çπ5000, B = ‚Çπ3000 ‚Üí Total = ‚Çπ8000

After Transaction (‚Çπ1000 A to B):
   A = ‚Çπ4000, B = ‚Çπ4000 ‚Üí Total = ‚Çπ8000 ‚úÖ

Constraint Check: Both balances ‚â• 0 ‚úÖ
                </pre>
                    </div>
                </div>

                <!-- Isolation -->
                <div class="acid-card">
                    <h3>üîí Isolation</h3>
                    <p>Each transaction executes independently without interference from concurrent transactions. Intermediate results of one transaction are not visible to others until completion.</p>
                    <div class="example">
                        <h4>üí° Real-World Example:</h4>
                        <p style="color: black; font-style: italic;">Two users making simultaneous transfers from the same account should not see each other's intermediate balance calculations, preventing incorrect final balances.</p>
                        <pre>
User 1: Transfer ‚Çπ500 A ‚Üí B (concurrent)
User 2: Transfer ‚Çπ300 A ‚Üí C (concurrent)

-- Isolation ensures both transactions see the original
-- balance of A and calculate correctly without interference
                </pre>
                    </div>
                </div>

                <!-- Durability -->
                <div class="acid-card">
                    <h3>üíæ Durability</h3>
                    <p>Once a transaction is committed successfully, the changes are permanently stored and will survive system crashes, power failures, or other system problems.</p>
                    <div class="example">
                        <h4>üí° Real-World Example:</h4>
                        <p style="color:black; font-style: italic;">After a successful online payment shows "Transaction Complete", even if the system crashes immediately afterward, the payment record is permanently saved and cannot be lost.</p>
                        <pre>
COMMIT TRANSACTION ‚Üí SUCCESS

-- Data written to persistent storage (disk/logs)
-- After power failure: data recovered from logs ‚úÖ
-- Transaction effects are permanent
                </pre>
                    </div>
                </div>
            </div>

            <div class="key-point">
                <strong>Interview Tip:</strong> Always explain ACID with concrete examples. Interviewers often ask: "What happens if a bank transfer fails halfway through?" The answer demonstrates your understanding of Atomicity.
            </div>
        </div>

        <div class="section">
            <h2>ü§ù Concurrent Execution</h2>
            <p>When <strong>multiple transactions execute simultaneously</strong> on the same database, it's called <strong>concurrent execution</strong>. This is essential for modern database performance.</p>

            <div class="note-tip">
                <strong>Why is Concurrency Important?</strong> It improves system throughput, reduces response time, and provides better user experience by allowing multiple users to work simultaneously.
            </div>

            <div class="example">
                <h4>üé¨ Movie Ticket Booking Example</h4>
                <p>Consider a popular movie release where thousands of users are booking tickets simultaneously. The system must process many concurrent transactions while ensuring that:</p>

                <pre>Transaction 1: User A books Seat 5A at 2:15 PM
Transaction 2: User B books Seat 7C at 2:15 PM  
Transaction 3: User C attempts Seat 5A at 2:15 PM ‚Üê Must be prevented!

Result: Only User A gets Seat 5A, User C sees "Seat Unavailable"</pre>
            </div>

            <div class="key-point">
                <strong>Key Challenge:</strong> Concurrent execution must maintain data consistency while maximizing performance. Poor concurrency control can lead to data corruption, incorrect results, or system deadlocks.
            </div>
        </div>

        <div class="section">
            <h2>üîÑ Transaction States</h2>
            <p>Every transaction in a DBMS goes through a well-defined sequence of states to ensure safe execution and proper recovery capabilities.</p>

            <div class="image-container">
                <img src="https://www.scaler.com/topics/images/transaction-state-in-dbms1.webp"
                    alt="Transaction States in DBMS" style="max-width: 100%; border-radius: 8px; margin-bottom: 10px;">
                <p><em>Transaction State Diagram showing the lifecycle from Active to Terminated</em></p>
            </div>

            <h3>üß≠ Detailed Explanation of Transaction States</h3>
            <table>
                <tr>
                    <th>State</th>
                    <th>Description</th>
                    <th>Next State</th>
                    <th>Real-World Example</th>
                </tr>
                <tr>
                    <td><span class="code-inline">Active</span></td>
                    <td>Transaction is currently executing read/write operations</td>
                    <td>‚Üí Partially Committed (success)<br>‚Üí Failed (error occurs)</td>
                    <td>User clicks "Transfer ‚Çπ500" and operations are being processed</td>
                </tr>
                <tr>
                    <td><span class="code-inline">Partially Committed</span></td>
                    <td>All operations completed successfully, but changes not yet made permanent</td>
                    <td>‚Üí Committed (if write to disk succeeds)<br>‚Üí Failed (if write fails)</td>
                    <td>Transfer calculations complete, waiting for database write confirmation</td>
                </tr>
                <tr>
                    <td><span class="code-inline">Committed</span></td>
                    <td>All changes successfully written to permanent storage</td>
                    <td>‚Üí Terminated</td>
                    <td>User sees "Transfer Successful" message, money actually moved</td>
                </tr>
                <tr>
                    <td><span class="code-inline">Failed</span></td>
                    <td>Error occurred during execution, transaction cannot proceed</td>
                    <td>‚Üí Aborted</td>
                    <td>Network timeout during transfer or insufficient balance detected</td>
                </tr>
                <tr>
                    <td><span class="code-inline">Aborted</span></td>
                    <td>Transaction rolled back, all changes undone</td>
                    <td>‚Üí Terminated</td>
                    <td>Failed transfer rolled back, original balances restored</td>
                </tr>
                <tr>
                    <td><span class="code-inline">Terminated</span></td>
                    <td>Transaction completed (either successfully committed or aborted)</td>
                    <td>End state</td>
                    <td>System ready for new transactions, resources freed</td>
                </tr>
            </table>

            <div class="example">
                <h4>üìò Complete Transaction Lifecycle Example</h4>
                <pre>
Mobile Recharge Transaction:

1. ACTIVE: BEGIN TRANSACTION
2. ACTIVE: READ(wallet_balance) ‚Üí ‚Çπ1000
3. ACTIVE: wallet_balance = wallet_balance - ‚Çπ100 ‚Üí ‚Çπ900
4. ACTIVE: WRITE(wallet_balance)
5. ACTIVE: Send recharge request to telecom provider
6. PARTIALLY COMMITTED: All operations executed successfully

If telecom confirms recharge:
7. COMMITTED: Changes written to disk
8. TERMINATED: Show "Recharge Successful"

If telecom rejects recharge:
7. FAILED: Recharge request denied
8. ABORTED: Rollback wallet_balance to ‚Çπ1000
9. TERMINATED: Show "Recharge Failed"
    </pre>
            </div>
        </div>

        <div class="section">
            <h2>üìÖ What is a Schedule?</h2>
            <p>A <strong>Schedule</strong> is the chronological order in which operations from multiple concurrent transactions are executed by the database system.</p>

            <div class="example">
                <h4>üìä Types of Schedules:</h4>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                    <div>
                        <h5>üîÑ Serial Schedule</h5>
                        <pre>T1: READ(A) ‚Üí WRITE(A) ‚Üí COMMIT
T2: READ(B) ‚Üí WRITE(B) ‚Üí COMMIT</pre>
                        <p><em>Transactions execute one after another (no overlap)</em></p>
                        <div class="success-card">
                            <p><strong>Advantage:</strong> Always consistent and safe</p>
                            <p><strong>Disadvantage:</strong> Poor performance due to no parallelism</p>
                        </div>
                    </div>

                    <div>
                        <h5>üîÄ Concurrent Schedule</h5>
                        <pre>T1: READ(A)
T2: READ(B)
T1: WRITE(A)
T2: WRITE(B)
T1: COMMIT
T2: COMMIT</pre>
                        <p><em>Operations from different transactions are interleaved</em></p>
                        <div class="warning">
                            <p><strong>Advantage:</strong> Better performance and resource utilization</p>
                            <p><strong>Risk:</strong> May cause data inconsistency if not properly controlled</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="key-point">
                <strong>Important:</strong> The goal of concurrency control is to ensure that concurrent schedules produce the same results as some serial schedule, maintaining both performance and consistency.
            </div>
        </div>

        <div class="section">
            <h2>‚ö†Ô∏è Concurrency Control Problems</h2>
            <p>When multiple transactions execute concurrently without proper control mechanisms, several serious problems can occur that compromise data integrity and consistency.</p>

            <h3>üí• 1. Dirty Read (Reading Uncommitted Data)</h3>
            <div class="danger-card">
                <h4>Problem Definition</h4>
                <p>A transaction T2 reads data that has been modified by transaction T1, but T1 has not yet committed. If T1 later aborts, T2 has used incorrect data for its operations.</p>

                <h5>üõçÔ∏è Real-World Example: Online Shopping</h5>
                <p>Your friend T1 adds ‚Çπ500 worth of items to their cart (reducing available inventory), and you T2 check the stock showing "2 items left". However, T1's payment fails and the transaction rolls back. You made your purchase decision based on incorrect stock information.</p>

                <div style="text-align: center; margin: 20px 0;">
                    <img src="https://www.gatevidyalay.com/wp-content/uploads/2018/05/Dirty-Read-Problem-Concurrency-Problems-in-DBMS.png"
                        alt="Dirty Read Problem Timeline" style="max-width: 100%; border: 1px solid #ccc; border-radius: 8px;">
                    <p style="font-style: italic; font-size: 14px;">Timeline showing how T2 reads uncommitted changes from T1</p>
                </div>

                <h5>üß† Step-by-Step Analysis:</h5>
                <ul>
                    <li><strong>t1‚Äìt3 (T1):</strong> T1 reads account A, deducts ‚Çπ500, writes new balance (uncommitted)</li>
                    <li><strong>t4‚Äìt5 (T2):</strong> T2 reads A's modified value and uses it for calculation</li>
                    <li><strong>t6 (T1):</strong> T1 encounters an error and must abort</li>
                    <li><strong>t7 (T1):</strong> T1 rolls back, undoing its changes</li>
                    <li><strong>t8 (T2):</strong> T2 commits based on the incorrect data it read</li>
                </ul>

                <div style="color: #dc3545; font-weight: bold; margin-top: 15px;">
                    üî¥ Result: T2 committed changes based on data that was never actually committed, leading to inconsistent database state.
                </div>
            </div>

            <h3>üìù 2. Lost Update Problem</h3>
            <div class="danger-card">
                <h4>Problem Definition</h4>
                <p>Two transactions read the same data item, modify it independently, and both update the database. The update from one transaction overwrites the update from the other, resulting in lost changes.</p>

                <h5>üõçÔ∏è Real-World Example: Inventory Management</h5>
                <p>Alice and Bob are both warehouse managers updating the same product's quantity. Alice reduces it by 1 (sold), Bob increases it by 3 (restocked). Due to poor timing, Bob's update overwrites Alice's, making it appear the sale never happened.</p>

                <div style="text-align: center; margin: 20px 0;">
                    <img src="https://s3-us-west-1.amazonaws.com/morpheus-staging/system/spud_media/466/original/lostupdate001.png?1424555949"
                        alt="Lost Update Example" style="max-width: 100%; border: 1px solid #ccc; border-radius: 8px;">
                    <p style="font-style: italic; font-size: 14px;">Timeline showing how Bob's update overwrites Alice's changes</p>
                </div>

                <h5>üß† Step-by-Step Analysis:</h5>
                <ul>
                    <li><strong>Step 1:</strong> Alice reads quantity = 7 (original value)</li>
                    <li><strong>Step 2:</strong> Bob reads quantity = 7 (same original value)</li>
                    <li><strong>Step 3:</strong> Alice calculates 7-1=6 and commits her update</li>
                    <li><strong>Step 4:</strong> Bob calculates 7+3=10 (based on original value) and commits</li>
                    <li><strong>Final Result:</strong> Database shows quantity = 10, but should be 9 (7-1+3)</li>
                </ul>

                <div style="color: #dc3545; font-weight: bold; margin-top: 15px;">
                    üî¥ Result: Alice's sale record is completely lost. Inventory count is incorrect, potentially causing financial losses.
                </div>
            </div>

            <h3>üîÑ 3. Non-Repeatable Read</h3>
            <div class="danger-card">
                <h4>Problem Definition</h4>
                <p>A transaction reads the same data item multiple times and gets different values because another transaction modified and committed the data between the reads.</p>

                <h5>üõçÔ∏è Real-World Example: Price Comparison</h5>
                <p>You're comparing product prices: first read shows ‚Çπ1000, you check other products, then read the same product again and see ‚Çπ1200. Another user's price update transaction occurred between your two reads.</p>

                <pre>
T1 (Your Session):
    READ(product_price) ‚Üí ‚Çπ1000
    ... (checking other products)
T2 (Admin Session):
    UPDATE product_price = ‚Çπ1200
    COMMIT
T1 continues:
    READ(product_price) ‚Üí ‚Çπ1200 (different value!)
                </pre>

                <div style="color: #dc3545; font-weight: bold; margin-top: 15px;">
                    üî¥ Result: Your transaction sees inconsistent data, making it difficult to make reliable decisions within a single transaction.
                </div>
            </div>

            <h3>üëª 4. Phantom Read</h3>
            <div class="danger-card">
                <h4>Problem Definition</h4>
                <p>A transaction executes a query (with WHERE condition) multiple times and gets different result sets because another transaction inserted or deleted rows that match the condition.</p>

                <h5>üõçÔ∏è Real-World Example: Report Generation</h5>
                <p>You're generating a sales report for products priced above ‚Çπ500. First query returns 10 products. While processing, new products are added. Second query returns 15 products, creating inconsistent report data.</p>

                <pre>
T1 (Report Generation):
    SELECT COUNT(*) FROM products WHERE price > 500; ‚Üí 10 rows
T2 (Product Addition):
    INSERT INTO products VALUES ('New Product', 600);
    COMMIT
T1 continues:
    SELECT * FROM products WHERE price > 500; ‚Üí 11 rows (phantom!)
                </pre>

                <div style="color: #dc3545; font-weight: bold; margin-top: 15px;">
                    üî¥ Result: Your report contains inconsistent counts and data, potentially leading to incorrect business decisions.
                </div>
            </div>

            <div class="key-point">
                <strong>Solution Preview:</strong> These problems are solved using isolation levels (READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE) and locking mechanisms which we'll cover in advanced topics.
            </div>
        </div>

        <div class="section">
            <h2>üîÑ Schedule Recoverability</h2>
            <p>When multiple transactions interact with shared data, the system must ensure that it can recover properly from failures. This leads us to classify schedules based on their recoverability properties.</p>

            <h3>‚úÖ Recoverable Schedule</h3>
            <div class="success-card">
                <h4>Definition</h4>
                <p>A schedule is <strong>recoverable</strong> if, for every pair of transactions T1 and T2, if T2 reads data written by T1, then T1 must commit before T2 commits.</p>

                <h5>üõçÔ∏è Real-World Example: Payroll Processing</h5>
                <p>T1 calculates and updates an employee's salary to ‚Çπ80,000. T2 reads this salary to generate tax calculations. T2 only commits its tax calculations AFTER T1 has successfully committed the salary update.</p>

                <pre>
T1: WRITE(salary = ‚Çπ80,000)
T1: COMMIT ‚úÖ
T2: READ(salary) ‚Üí ‚Çπ80,000
T2: Calculate taxes based on ‚Çπ80,000
T2: COMMIT ‚úÖ
                </pre>

                <div style="color: #28a745; font-weight: bold; margin-top: 15px;">
                    ‚úÖ Safe: If T1 had failed, T2 would not have committed incorrect tax calculations. Recovery is possible by rolling back T2 if needed.
                </div>
            </div>

            <h3>‚ùå Non-Recoverable Schedule</h3>
            <div class="danger-card">
                <h4>Definition</h4>
                <p>A schedule is <strong>non-recoverable</strong> if a transaction T2 commits after reading uncommitted data from T1, and then T1 aborts. This makes recovery impossible.</p>

                <h5>üõçÔ∏è Real-World Example: Loan Approval</h5>
                <p>T1 updates a customer's credit score to 750. T2 reads this score and approves a loan (commits). Later, T1 encounters an error and rolls back the credit score update. The loan was approved based on invalid data!</p>

                <pre>
T1: WRITE(credit_score = 750)
T2: READ(credit_score) ‚Üí 750
T2: Approve loan based on score 750
T2: COMMIT ‚úÖ (loan approved)
T1: ABORT ‚ùå (credit score rollback)
                </pre>

                <div style="color: #dc3545; font-weight: bold; margin-top: 15px;">
                    ‚ùå Dangerous: T2 has already committed the loan approval, but it was based on data that was never actually committed. This cannot be undone automatically.
                </div>
            </div>

            <h3>üîÑ Cascading vs Cascadeless Schedules</h3>
            
            <h4>‚úÖ Cascadeless Schedule (No Cascading Rollback)</h4>
            <div class="success-card">
                <p><strong>Definition:</strong> A transaction only reads data from other transactions that have already committed. This prevents cascading rollbacks.</p>

                <div style="text-align: center; margin: 20px 0;">
                    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20250115150841846842/cascadeless_schedule_1.webp" 
                         alt="Cascadeless Schedule Example" 
                         style="max-width: 100%; border: 1px solid #ccc; border-radius: 8px;">
                    <p style="font-style: italic; font-size: 14px;">T2 and T3 only read data after T1 commits - ensuring no cascading rollback</p>
                </div>

                <h5>üß† Timeline Analysis:</h5>
                <ul>
                    <li><strong>T1:</strong> Modifies data X, then commits</li>
                    <li><strong>T2:</strong> Reads X only AFTER T1 commits, then commits</li>
                    <li><strong>T3:</strong> Reads X only AFTER T2 commits, then commits</li>
                </ul>

                <div style="color: #28a745; font-weight: bold; margin-top: 15px;">
                    ‚úÖ Advantage: Even if T1 fails during execution, T2 and T3 are unaffected because they never read uncommitted data. No chain reaction of rollbacks.
                </div>
            </div>

            <h4>‚ö†Ô∏è Cascading Schedule (Chain Rollback Risk)</h4>
            <div class="problem-card">
                <p><strong>Definition:</strong> When transactions read uncommitted data from other transactions, creating a chain where failure of one transaction forces rollback of multiple dependent transactions.</p>

                <div style="text-align: center; margin: 20px 0;">
                    <img src="https://www.gatevidyalay.com/wp-content/uploads/2018/06/Cascading-Schedule-Cascading-Rollback-Cascading-Abort-1.png" 
                         alt="Cascading Schedule Example" 
                         style="max-width: 100%; border: 1px solid #ccc; border-radius: 8px;">
                    <p style="font-style: italic; font-size: 14px;">T2, T3, T4 all read uncommitted data - creating a cascade effect if T1 fails</p>
                </div>

                <h5>üß† Chain Reaction Analysis:</h5>
                <ul>
                    <li><strong>T1:</strong> Modifies data X but fails before committing</li>
                    <li><strong>T2:</strong> Read X from T1 (uncommitted) ‚Üí Must rollback</li>
                    <li><strong>T3:</strong> Read X from T2 (now invalid) ‚Üí Must rollback</li>
                    <li><strong>T4:</strong> Read X from T3 (now invalid) ‚Üí Must rollback</li>
                </ul>

                <div style="color: #f39c12; font-weight: bold; margin-top: 15px;">
                    ‚ö†Ô∏è Problem: One transaction's failure causes a domino effect, rolling back multiple transactions and significantly impacting system performance.
                </div>
            </div>
        </div>

        <div class="section">
            <h2>üîê Deadlock in Database Systems</h2>
            <p>A <strong>deadlock</strong> occurs when two or more transactions are blocked indefinitely, each waiting for the other to release resources they need.</p>

            <div class="example">
                <h4>üîÑ Classic Deadlock Example</h4>
                <p>Consider two users trying to transfer money between the same two accounts simultaneously:</p>
                
                <pre>
Transaction T1 (User A): Transfer ‚Çπ100 from Account X to Account Y
1. LOCK Account X
2. Wait for LOCK on Account Y (held by T2)

Transaction T2 (User B): Transfer ‚Çπ200 from Account Y to Account X  
1. LOCK Account Y
2. Wait for LOCK on Account X (held by T1)

Result: Both transactions wait forever!
                </pre>
            </div>

            <div class="danger-card">
                <h4>üö® Deadlock Conditions (All must be present)</h4>
                <ul>
                    <li><strong>Mutual Exclusion:</strong> Resources cannot be shared simultaneously</li>
                    <li><strong>Hold and Wait:</strong> Transactions hold resources while waiting for others</li>
                    <li><strong>No Preemption:</strong> Resources cannot be forcibly taken away</li>
                    <li><strong>Circular Wait:</strong> A chain of transactions each waiting for the next</li>
                </ul>
            </div>

            <div class="success-card">
                <h4>üõ†Ô∏è Deadlock Prevention Strategies</h4>
                <ul>
                    <li><strong>Resource Ordering:</strong> Always acquire locks in a predefined order (e.g., by account number)</li>
                    <li><strong>Timeout Mechanisms:</strong> Abort transaction if it waits too long for a resource</li>
                    <li><strong>Deadlock Detection:</strong> Use algorithms to detect cycles in wait-for graphs</li>
                    <li><strong>Timestamp Ordering:</strong> Older transactions get priority over newer ones</li>
                </ul>
            </div>

            <div class="example">
                <h4>üí° Deadlock Prevention in Practice</h4>
                <pre>
// Instead of this (can cause deadlock):
Transaction T1: LOCK(Account_5), LOCK(Account_3)
Transaction T2: LOCK(Account_3), LOCK(Account_5)

// Use this (ordered locking):
Transaction T1: LOCK(Account_3), LOCK(Account_5)  // Always lower ID first
Transaction T2: LOCK(Account_3), LOCK(Account_5)  // Same order prevents deadlock
                </pre>
            </div>
        </div>

      

        <div class="section">
            <h2>üß† Real-World Applications</h2>
            <div class="summary-grid">
                <div class="summary-card">
                    <h4>üí≥ Banking Systems</h4>
                    <p>Use <strong>SERIALIZABLE</strong> isolation for money transfers to ensure absolute consistency</p>
                </div>

                <div class="summary-card">
                    <h4>üõí E-commerce</h4>
                    <p>Use <strong>READ COMMITTED</strong> for product catalogs, <strong>SERIALIZABLE</strong> for checkout</p>
                </div>

                <div class="summary-card">
                    <h4>üìä Analytics</h4>
                    <p>Use <strong>READ UNCOMMITTED</strong> for reports where slight inconsistency is acceptable for speed</p>
                </div>

                <div class="summary-card">
                    <h4>üéÆ Gaming</h4>
                    <p>Use <strong>REPEATABLE READ</strong> for player stats, preventing mid-game inconsistencies</p>
                </div>

                <div class="summary-card">
                    <h4>üè• Healthcare</h4>
                    <p>Use <strong>SERIALIZABLE</strong> for patient records where data accuracy is life-critical</p>
                </div>

                <div class="summary-card">
                    <h4>üì± Social Media</h4>
                    <p>Use <strong>READ COMMITTED</strong> for feeds, allowing real-time updates without blocking</p>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>üéØ Interview Preparation Guide</h2>
            <div class="highlight">
                <h4>üî• Most Asked Interview Questions</h4>
                <ul style="margin-left: 20px;">
                    <li><strong>Explain ACID properties with banking examples</strong> - Focus on atomicity in money transfers</li>
                    <li><strong>What problems occur in concurrent execution?</strong> - Dirty read, lost update, phantom read</li>
                    <li><strong>How do you prevent deadlocks?</strong> - Resource ordering, timeouts, detection algorithms</li>
                    <li><strong>Difference between recoverable and cascadeless schedules?</strong> - Commit ordering and rollback implications</li>
                    <li><strong>Which isolation level would you choose for a banking app?</strong> - SERIALIZABLE with justification</li>
                    <li><strong>Design a solution for the lost update problem</strong> - Locking mechanisms or optimistic concurrency</li>
                </ul>
            </div>

            <div class="key-point">
                <strong>Pro Tip:</strong> Always provide concrete examples. Instead of saying "atomicity ensures all-or-nothing," explain "if transferring ‚Çπ1000 fails after debiting sender, the system automatically reverses the debit."
            </div>

            <div class="warning">
                <strong>Common Mistakes to Avoid:</strong>
                <ul>
                    <li>Confusing consistency (ACID) with consistency (CAP theorem)</li>
                    <li>Thinking higher isolation levels are always better (they reduce performance)</li>
                    <li>Not understanding that deadlock prevention and detection are different approaches</li>
                    <li>Mixing up recoverable vs serializable schedules</li>
                </ul>
            </div>
        </div>

       

    </div>
</body>
</html>